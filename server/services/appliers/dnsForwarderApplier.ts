/**
 * DNS转发器配置应用器
 * 负责将数据库中的DNS配置应用到系统
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';

const execAsync = promisify(exec);

const DNSMASQ_CONFIG_DIR = '/etc/dnsmasq.d';
const DNSMASQ_DNS_CONFIG_FILE = path.join(DNSMASQ_CONFIG_DIR, 'dns-forwarders.conf');
const RESOLV_CONF_FILE = '/etc/resolv.conf';

export interface DnsForwarder {
  id: number;
  dnsServer: string;
  priority: number | null;
  enabled: number | null;
}

/**
 * 应用所有DNS转发器到系统
 */
export async function applyDnsForwarders(forwarders: DnsForwarder[]): Promise<{ success: boolean; message: string }> {
  try {
    // 确保配置目录存在
    try {
      await fs.mkdir(DNSMASQ_CONFIG_DIR, { recursive: true });
    } catch (error) {
      // 目录可能已存在
    }

    // 只使用启用的转发器
    const enabledForwarders = forwarders
      .filter(f => f.enabled === 1)
      .sort((a, b) => (a.priority || 0) - (b.priority || 0));

    // 生成dnsmasq配置文件内容
    const configLines = [
      '# URouterOS DNS Forwarders Configuration',
      '# Generated by URouterOS - DO NOT EDIT MANUALLY',
      '',
      '# DNS servers (in priority order)',
    ];

    for (const forwarder of enabledForwarders) {
      configLines.push(`server=${forwarder.dnsServer}`);
    }

    configLines.push('');
    configLines.push('# Additional DNS options');
    configLines.push('no-resolv'); // 不读取/etc/resolv.conf
    configLines.push('');

    // 写入dnsmasq配置文件
    await fs.writeFile(DNSMASQ_DNS_CONFIG_FILE, configLines.join('\n'), 'utf-8');

    // 重启dnsmasq服务
    try {
      await execAsync('systemctl restart dnsmasq');
      return { 
        success: true, 
        message: `成功应用${enabledForwarders.length}个DNS转发器配置` 
      };
    } catch (error) {
      return { 
        success: false, 
        message: `配置已保存但重启服务失败: ${error instanceof Error ? error.message : String(error)}` 
      };
    }
  } catch (error) {
    console.error('Failed to apply DNS forwarders:', error);
    return { 
      success: false, 
      message: `应用配置失败: ${error instanceof Error ? error.message : String(error)}` 
    };
  }
}

/**
 * 验证DNS服务器地址格式
 */
export function validateDnsServer(dns: string): boolean {
  // 支持IPv4地址
  const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  if (ipv4Regex.test(dns)) {
    const parts = dns.split('.');
    return parts.every(part => {
      const num = parseInt(part, 10);
      return num >= 0 && num <= 255;
    });
  }

  // 支持IPv6地址
  const ipv6Regex = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;
  if (ipv6Regex.test(dns)) {
    return true;
  }

  // 支持域名
  const domainRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  if (domainRegex.test(dns)) {
    return true;
  }

  return false;
}

/**
 * 清空所有DNS转发器配置
 */
export async function clearDnsForwarders(): Promise<{ success: boolean; message: string }> {
  try {
    // 写入空配置文件
    const configLines = [
      '# URouterOS DNS Forwarders Configuration',
      '# Generated by URouterOS - DO NOT EDIT MANUALLY',
      '',
      '# No DNS forwarders configured',
      '# Using default DNS resolution',
      '',
    ];

    await fs.writeFile(DNSMASQ_DNS_CONFIG_FILE, configLines.join('\n'), 'utf-8');

    // 重启dnsmasq服务
    try {
      await execAsync('systemctl restart dnsmasq');
      return { success: true, message: '已清空所有DNS转发器配置' };
    } catch (error) {
      return { 
        success: false, 
        message: `配置已清空但重启服务失败: ${error instanceof Error ? error.message : String(error)}` 
      };
    }
  } catch (error) {
    console.error('Failed to clear DNS forwarders:', error);
    return { 
      success: false, 
      message: `清空配置失败: ${error instanceof Error ? error.message : String(error)}` 
    };
  }
}

/**
 * 获取当前系统DNS配置
 */
export async function getCurrentDnsServers(): Promise<string[]> {
  try {
    const content = await fs.readFile(RESOLV_CONF_FILE, 'utf-8');
    const lines = content.split('\n');
    const dnsServers: string[] = [];

    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed.startsWith('nameserver ')) {
        const dns = trimmed.split(/\s+/)[1];
        if (dns) {
          dnsServers.push(dns);
        }
      }
    }

    return dnsServers;
  } catch (error) {
    console.error('Failed to read current DNS servers:', error);
    return [];
  }
}
